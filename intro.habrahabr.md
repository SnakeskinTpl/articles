Язык описания шаблонов Snakeskin
================================

Всем привет! В этом посте я хочу рассказать о своей разработке: ЯП для описания тектовых шаблонов - Snakeskin.
Проекту уже более 3.5 лет, и мне кажется, что все детские болезни он пережил, поэтому я могу поделиться результатом с сообществом.

[GitHub](https://github.com/SnakeskinTpl/Snakeskin)
[Документация](http://snakeskintpl.github.io/docs/index-ru.html) (английская версия пока не сделана)
[Смежные проекты](https://github.com/SnakeskinTpl)

## Что, зачем и почему

Так что же за зверь Snakeskin (далее SS) и зачем я его написал? Мне нравится определение, что SS - это как CoffeeScript или TypeScript, 
т.е. просто "сахарный" синтаксис для JavaScript + дополнительные приятные фичи, которые помогают писать код. 
Но в отличии от этих языков SS имеет явную специализацию - это описание шаблонов, т.е. конечно можно писать на SS приложения целиком,
но это просто будет не удобно. SS используется не вместо, а вместе с основным языком, например:

**select.ss**

```
- namespace select
- template main(options, params)
  < select
    - forEach options => el
      < option {el.value}
        {el.label}
```

**select.js**

```js
import { select } from 'select.ss';

class Select {
  constructor() {
    this.template = select.main;
  }
}
```

Тут мы описали некоторый класс на JS (ES2015) и подключили как модуль файл написанный на Snakeskin 
(такую интеграцию делает плагин для WebPack), а далее ставим шаблон *main*, как метод класса.

Теперь можно сделать некоторые выводы:

* SS транслируется в JS, который потом бесшовно используется с основным кодом;
* SS полностью сконцентрирован на генерации шаблонов, но в принципе всё, что можно написать на JS - можно написать и на SS.

Зачем же я написал Snakeskin? Дело в том, что мне очень хотелось иметь один язык шаблонов с мощной системой code-reuse как на сервере,
так и на клиенте, причём на клиенте я использует фреймворк (в данный момент Vue), который, как правило, имеет свой язык шаблонов и SS обязан с ним
бесшовно интегрироваться.

Теперь рассмотрим основные use-case для Snakeskin:

* Серверная шаблонизация: тут всё просто, подключаем SS шаблон как модуль node.js и работает с его функциями, например:

```js
'use strict';

const http = require('http');
const ss = require('snakeskin');

/// Компилируем файл шаблонов:
/// метод вернёт объект с функциями-шаблонами
const tpls = ss.compileFile('./myTpls.ss');

http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/html'});
  
  // Вызываем шаблон foo и передаём параметры
  res.write(tpls.foo('bar', 'bla'));
  res.end();
}).listen(8888);
```

Разумется на практике мы будем использовать фреймворк для приложения, например, Express или Koa, но это не имеет значения.
Также следует отметить, что шаблоны можно транслировать предварительно (например, с помощью Gulp или Grunt) и подключать
полученные файлы, или же опять таки - можно использовать подход с WebPack.

* Генерация статических сайтов: с помощью плагинов интеграции (Gulp, Grunt, WebPack и т.д.) мы немедленно вызываем 
скомпилированный шаблон и сохраняем его результат. Следует отметить что "шаблон для вызова" либо указывается явно,
либо будет вычислен по формуле: `%fileName% || main || index || Object.keys().sort()[0];`, где `%fileName%` - имя
главного файла-шаблона без расширения (т.е. тот файл, на который мы натравливаем плагин).

* Использование транслированных в JS шаблонов на клиенте: полученные функции можно подключать через внешний тег `<script />`
или как модуль (с помощью WebPack), причём SS имеет ряд механизмов для удобной интеграции шаблонов СС с различными фреймворками,
например, Angular или Vue.

**Пример интеграции Angular + SS:**

```
- namespace myApp
- template main()
  < label
    Name:
  < input type = text | ng-model = yourName | placeholder = Enter a name here
  < hr
  < h1
    Hello {{yourName}}!
```

Snakeskin решает проблему "простыни" кода, code-reuse элементов вёрстки (через наследование, композицию, примеси и т.д.),
а Angular делает data-binding. С технической точки зрения SS генерирует шаблон, который потом использует Angular.

## Язык

Теперь, когда я описал свои мотивы и основые use-case, я расскажу про сам язык, но цель данного поста не дублирование 
[документации](http://snakeskintpl.github.io/docs/index-ru.html), а общий обзор.

### Концепция

Шаблон Snakeskin - это функция JavaScript, т.е. грубо говоря

```
- namespace myApp
- template main()
  Hello world!
```

после трансляции превратится в:

```
if (exports.demo === 'undefined') {
	var myApp = exports.myApp = {};
}

exports.myApp.main = function main() {
	return 'Hello world!';
}
```

Конечно - это упрощение, но суть ясна. Шаблоны - это функции JavaScript, которые, как правило, генерируют текст 
(в виде строки, DocumentFragment или другом заданном представлении).

### Синтаксис

SS, подобно Stylus, поддерживает 2 разных вида синтаксиса:

* основанный на директивах, которые заключены в фигурные скобки, например:
 
```
{namespace myApp}
{template main(name = 'world')}
  Hello {world}!
{/template}
```

Плюс такого подхода, что его удобно использовать для генерации текста, который основан на "управляемых пробелах", например,
Markdown. Также при таком подходе "блочные" директивы (т.е. которые могут включать в себя текст) обязаны явно закрываться.

* основанный на управляемых пробелах и идеологически близкий к Jade и HAML, перепишем пример данный выше:

```
- namespace myApp
- template main(name = 'world')
  Hello {world}!
```

Главные плюсы такого подхода - это краткость и наглядность, а также нет нужды в явном закрытии блочных директив.
Такой подход идеален для генерации XML подобных структур.

Также SS поддерживает смешивание синтаксисов, т.е. мы можем использовать одновременно оба подхода:

```
- namespace myApp

{template hello(name = 'world')}
  Hello {world}!
{/template}

- template main(name)
  += myApp.hello(name)
```

Подробнее про синтаксис можно узнать в [документации языка](http://snakeskintpl.github.io/docs/guide-ru.html#basics).

### code-reuse
#### Наследования

В SS каждый шаблон является классом, т.е. у него есть методы и свойства и он может наследоваться от другого шаблона.
При наследовании дочерний шаблон переопределяет родительские методы и свойства, а также может вводить новые, например:

```
- namespace myApp

/// Метод sayHello шаблона base
/// (аналог mixin в Jade)
- block base->sayHello(name = 'world')
  Hello {name}!

- template base()
  - doctype
  < html
    < head
      /// Статичный блок head
      /// (аналог блоков в Jade):
      /// чтобы сделать такой блок методом,
      /// достаточно просто добавить круглые скобки после имени
      - block head
        < title
          /// Свойство шаблона title
          {title = 'Главная страница' ?}
    
    < body
      - block body
        += self.sayHello()

/// Доопределяем родительский метод
- block child->sayHello(name = 'world')
  /// Вызов родителя
  - super
  Hello people!

/// Ввводим новый метод
- block child->go()
  Let's go!

- template child() extends myApp.base
  /// Переопределяем свойство
  - title = 'Дочерняя страница'
  
  /// Полностью переопределяем статичный блок
  - block body
    += self.go()
```

При наследовании шаблона также наследуются входные параметры, декораторы шаблона, различные модификаторы и т.д. - 
[подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#inheritBasic).

#### Композиция

Т.к. все шаблоны SS функции, то любой шаблон может содержать в своём теле вызов другого шаблона и т.д.

```
- namespace myApp

- template hello(name = 'world')
  Hello {world}!

- template main(name)
  += myApp.hello(name)
```

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#call)

#### Шаблонные литералы

SS позволяет создать переменную со значением некоторого подшаблона, передать его в другой шаблона и т.д.

```
- namespace myApp

- template wrap(content)
  < .wrapper
    {content}

- template main(name)
  += myApp.wrap()
    < .hello
      Hello world!
```

### Модули

SS может подключать другие файлы шаблоны с помощью директивы [include](http://snakeskintpl.github.io/docs/api-ru.html#include),
т.е. позволяет разбить код на логические части или создавать подключаемые библиотеки и т.д. Каждый файл образует модуль 
и глобальные переменные уровня шаблоны находятся инкапсулированы в нём, а все шаблоны - экспортируются. 

**math.ss**

```
- namespace math
- template calc(a, b)
  {a + b}
```

**app.ss**

```
- namespace app
- include './math'

- template main()
  += math.calc(1, 2)
```

### Основные фичи
