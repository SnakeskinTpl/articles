Язык описания шаблонов Snakeskin
================================

Привет! Хочу рассказать о своей разработке - языке программирования текстовых шаблонов "Snakeskin".
Проекту больше трех лет, всеми детскими болезнями, я полагаю, он благополучно переболел (и излечился), 
поэтому хочу поделиться результатом.

[Основной репозиторий](https://github.com/SnakeskinTpl/Snakeskin)

[Документация](http://snakeskintpl.github.io/docs/index-ru.html)

[Плагины для Gulp, Grunt, Webpack и прочее](https://github.com/SnakeskinTpl)

## Немного истории

Когда я работал в Яндексе (года четыре назад), одной из самых частых тем для жарких дискуссий на кофе-поинтах у нас с коллегами были шаблонизаторы: мы обсуждали достоинства и недостатки существующих решений, некоторые даже разрабатывали свои собственные.

В отделе основным был TemplateToolkit2 - популярный в частности у Perl-разработчиков шаблонизатор, а на клиенте использовался простейший MicroTemplate (by Джон Резиг). Ещё в то время активно форсились XSLT-подобные движки, но по ряду причин (обсуждение которых лежит за рамками этой статьи) нам они не подошли. Время от времени мы экспериментировали и с другими: Handlebars, Dust, Closure Templates, плюс свои велосипеды, конечно же… Всё это привело к наличию целого зоопарка шаблонизаторов в проекте.

Моим фаворитом был Google Closure Templates: он был близок мне как программисту, т.к. шаблон позиционировался как функция, которая просто возвращает строку, плюс весьма неплохие по тем временам фичи; но очень огорчала необходимость править код на Java, чтобы добавить какой-нибудь банальный фильтр, да и скорость трансляции была не ахти (это реально ощущалось).

И я захотел сделать свой собственный Closure Templates ~~с блэкджеком и шлюхами~~: естественно, чтобы был написан на JS и, как следствие, открыт к модификациям без необходимости знать Java. Плюс, мне понравилась модель наследования шаблонов, основанная на статических блоках, которую я подсмотрел в Django Templates (отсюда и название – отсылка к шаблонизатору для Python). Она-то и легла в основу существующей системы наследования.

Прототип я набросал дня за три: это был жуткий хардкод на регулярках в семь сотен строк кода. С результатом я немного поигрался, поделился с коллегами, получил какой-никакой, но фидбэк, и решил двигаться дальше: я порефакторил это дело, поправил баги, добавил ~~новые~~ возможностей. После недели разработки я запилил версию 2 - это был по сути тот же хардкод на регулярках, но стабильней и фичастей. Его уже можно было использовать.

Поработав некоторое время с результатом и выпустив с десяток обновлений, я, потирая руки, сел за компьютер с мыслью "It's time to make things right", и где-то через месяц выпустил 3-ю версию: выкинул хардкод, переписал код на ES6 (в то время не было нормальных трансляторов, поэтому я ещё и [транслятор](https://github.com/kobezzza/NeJS) свой собственный запилил (опять же, с жутким хардкодом на регулярках – да-да, я люблю регулярки)), добавил построение дерева при парсинге и много новых фич.

Версия вышла стабильной, мощной и, по сути, представляла собой Closure Templates на стероидах. Я был доволен результатом и стал использовать Snakeskin в своих личных проектах, время от времени выпуская новые обновления и патчи. 

Чуть позже я познакомился с HAML и Jade, мне понравился их подход к синтаксису, и было решено добавить в Snakeskin нечто подобное (результатом стал Jade-like синтаксис). Спустя несколько месяцев активной разработки я выпустил четвертую версию, ставшую поистине вехой в истории языка и определившую его дальнейшее развитие. Пятая и шестая были не более чем модификацией четвёртой версии, но с ломающими изменениями, которые были необходимы, а так как в качестве паттерна версионирования для Snakeskin мною был выбран [SemVer](http://semver.org/) - пришлось апать мажорную версию.
 
SS6 я использовал довольно долго и в самых различных проектах, также его стали использовать мои знакомые и коллеги – в итоге, по прошествии времени, накопился список претензий к нему, небольшой, но чувствительный: фич было много, они были достаточно хаотичны, стали проявляться конфликты между директивами – причиной было отсутствие какой-либо начальной спецификации языка, а просто разработка его по мере появления «хотелок».

Я решил, что так дальше жить нельзя - нужно всё стандартизировать и удалить мусор. Разработка затянулась на полтора года (из которых, правда, активная была максимум полгода – сказывалась нехватка свободного времени), но в итоге получился самый стабильный и продуманный на данный момент релиз Snakeskin: версия 7; и я искренне им горжусь.


## Первый взгляд

Наиболее подходящим для Snakeskin мне кажется определение, что он - просто "сахар" над JS, как CoffeeScript или TypeScript, но имеет достаточно узкую специализацию: написание шаблонов. Конечно, вполне можно написать на SS хоть всё приложение целиком, но это будет, хех, не очень удобно. SS предназначен для использования вместе с основным языком - преимущественно, конечно, JS:

**select.ss**

```
- namespace select

- template main(options)
  < select 
    - forEach options => el
      < option value = ${el.value} 
        {el.label}
```

**select.js**

```js
import { select } from 'select.ss';

class Select {
  constructor(options) {
    this.template = select.main(options);
  }
}

const newSelect = new Select([{value: 1, label: 'Раз'}, {value: 2, label: 'Два'}])
```

Тут в основной файл на JS подключается как модуль файл на Snakeskin (такую бесшовную интеграцию дает, например, [плагин для WebPack](https://github.com/SnakeskinTpl/snakeskin-loader)). Из него импортируем namespace `select`, и объявляем класс `Select`. При создании инстанса `Select`, мы выполняем функцию `main` (в которую был транслирован шаблон `main`), и присваиваем свойству `template` результат её работы - для `newSelect` он будет таким: 

```html
<select>
  <option value="1">
    Раз
  </option>
  <option value="2">
    Два
  </option>
</select>
```

Как видите, SS транслируется в JS (если конкретно, то в ES5), который потом очень просто использовать в основном коде.

Основной мотивацией для написания Snakeskin было желание иметь язык шаблонов с развитыми возможностями для повторного использвания кода, и который можно было бы использовать на сервере и на клиенте одинаково, без необходимости изменения кода шаблона. 

Также от него требовалась бесшовная интеграция с фреймворками и библиотеками, которые имеют собственный язык шаблонов (вроде Angular или React - ну а я предпочитаю Vue) - и Snakeskin это отлично удаётся.

**Пример использования SS для создания шаблонов Angular:**

```
- namespace myApp
- template main()
  < label
    Name:
  < input type = text | ng-model = yourName | placeholder = Enter a name here
  < hr
  < h1
    Hello {{yourName}}!
```

**Результат работы `main`**

```html
<label>
  Name:
</label>
<input type="text" ng-model="yourName" placeholder="Enter a name here">
<hr>
<h1>
  Hello {{yourName}}!
</h1>
```

Snakeskin значительно сокращает количество кода, позволяет повторно использовать элементы вёрстки (через наследование, композицию, примеси и т.д.), а Angular осуществляет data-binding. С технической точки зрения SS генерирует шаблон, который потом использует Angular.

## Где можно использовать

* Серверная шаблонизация - тут всё просто: подключаем SS как модуль, компилируем файл, и node.js работает с его шаблонами как с функциями:

```js
'use strict';

const http = require('http');
const ss = require('snakeskin');

/// Компилируем файл шаблонов
/// Метод вернёт объект с шаблонами-функциями
const tpls = ss.compileFile('./myTpls.ss');

http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/html'});
  
  // Вызываем шаблон foo и передаём параметры
  res.write(tpls.foo('bar', 'bla'));
  res.end();
}).listen(8888);
```

Разумеется, на практике это будет серверный фреймворк типа Express или Koa, но это не имеет значения.
Также, шаблоны можно (и желательно) предварительно транслировать с помощью плагина для [Gulp](https://github.com/SnakeskinTpl/gulp-snakeskin) или [Grunt](https://github.com/SnakeskinTpl/grunt-snakeskin) и подключать полученные файлы, ну или, как выше - использовать WebPack.

* Генерация статических сайтов: у плагинов есть опция вызывать скомпилированный шаблон в момент трансляции и возвращать результат его работы. 
Плагин сам [вычислит главный шаблон](http://snakeskintpl.github.io/docs/api.html#execFile), либо его можно указать явно.

* Использование транслированных в JS шаблонов на клиенте: "скомпилированные" модули можно подключать через внешний тег `<script>`, 
либо как модуль (с помощью Webpack, Browserify, RequireJS или любой другой системы управлениями модулями).

## Краткий обзор языка

Здесь я пробегусь по основным концепциям, а если у вас останутся вопросы -- добро пожаловать в [документацию](http://snakeskintpl.github.io/docs/index-ru.html) или в [Gitter](https://gitter.im/SnakeskinTpl/Snakeskin).

### Основное

#### Шаблоны

Как уже неоднократно упоминалось, шаблон Snakeskin после трансляции становится функцией JavaScript:

```
- namespace myApp
- template main()
  Hello world!
```

после трансляции превратится в

```
if (exports.myApp === 'undefined') {
	var myApp = exports.myApp = {};
}

exports.myApp.main = function main() {
	return 'Hello world!';
}
```

Конечно, это упрощенный код, но в целом это выглядит примерно так. Результат шаблона может быть строкой (по умолчанию), в виде DocumentFragment или в любом другом заданном представлении.

#### Синтаксис

SS поддерживает 2 разных вида синтаксиса:

* **Classic**: директивы заключены в фигурные скобки; блочные (которые могут содержать внутри себя другой код на SS) должны быть явно закрыты:
 
```
{namespace myApp}
{template main(name = 'world')}
  Hello {name}!
{/template}
```

Этот режим удобно использовать для генерации текста с управляющими пробелами, например ~~кода на Python~~ Markdown. 

*Примечание*: для генерации текста, где часто используются символы фигурных скобок, в SS есть [специальный механизм](http://snakeskintpl.github.io/docs/guide-ru.html#basics--%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81).

* **Jade-like**: основан на управляющих пробелах и похож на Jade (отсюда и название). Пример выше с его использованием будет выглядеть так:

```
- namespace myApp
- template main(name = 'world')
  Hello {name}!
```

Главные плюсы этого синтаксиса - краткость и наглядность. Идеально подходит для генерации XML-подобных структур.

Также SS поддерживает смешанный синтаксис:

```
- namespace myApp

{template hello(name = 'world')}
  Hello {name}!
{/template}

- template main(name)
  += myApp.hello(name)
```

[Подробнее про синтаксис и его виды](http://snakeskintpl.github.io/docs/guide-ru.html#basics).

### Инструменты code-reuse
#### Наследование

В SS каждый шаблон является классом, т.е. у него есть методы и свойства, и он может наследоваться от другого шаблона.
При наследовании дочерний шаблон может переопределять родительские методы и свойства и добавлять новые.

**Пример наследования шаблонов**

```
- namespace myApp

/// Метод sayHello шаблона base
- block base->sayHello(name = 'world')
  Hello {name}!

- template base()
  - doctype
  
  < html
    < head
    
      /// Статичный блок head
      /// Чтобы сделать такой блок методом,
      /// достаточно просто добавить круглые скобки после имени
      
      - block head
        < title
          /// Свойство шаблона `title`, которое сразу выводится
          - title = 'Главная страница' ?
    
    < body
      - block body
        /// вызов метода sayHello
        += self.sayHello()

/// Доопределяем родительский метод
- block child->sayHello(name = 'world')
  /// Вызов родителя
  - super
  Hello people!

/// Ввводим новый метод
- block child->go()
  Let's go!

- template child() extends myApp.base
  /// Переопределяем свойство
  - title = 'Дочерняя страница'
  
  /// Переопределяем статичный блок
  - block body
    - super
    += self.go()
```

**Результат выполнения `child`**:
```html
<!DOCTYPE html>
<html>
<head>
  <title>Дочерняя страница</title>
</head>

<body> 
  Hello world! Hello people! Let's go!
</body>
</html>
```


При наследовании шаблона также наследуются входные параметры, декораторы шаблона, различные модификаторы - [подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#inheritBasic).

#### Композиция

Т.к. все шаблоны SS функции, то любой шаблон может содержать в своём теле вызов другого шаблона и т.д.

```
- namespace myApp

- template hello(name = 'world')
  Hello {name}!

- template main(name)
  += myApp.hello(name)
```

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#call)

#### Шаблонные литералы

SS позволяет создать переменную со значением некоторого подшаблона, передать его в другой шаблона и т.д.

```
- namespace myApp

- template wrap(content)
  < .wrapper
    {content}

- template main(name)
  += myApp.wrap()
    < .hello
      Hello world!
```

### Модули

SS может подключать другие файлы шаблоны с помощью директивы [include](http://snakeskintpl.github.io/docs/api-ru.html#include). Т.е. можно разбить код на логические части или создать подключаемые библиотеки.
Каждый файл образует модуль и глобальные переменные уровня шаблоны находятся инкапсулированы в нём, а все шаблоны - экспортируются. 

**math.ss**

```
- namespace math
- template calc(a, b)
  {a + b}
```

**app.ss**

```
- namespace myApp
- include './math'

- template main()
  += math.calc(1, 2)
```

### Основные фичи
#### Богатый набор встроенных директив

SS вводит директивы близких по семантике к JS ([if](http://snakeskintpl.github.io/docs/api-ru.html#if), [for](http://snakeskintpl.github.io/docs/api-ru.html#for) и т.д.), а также ряд дополнительных ([unless](http://snakeskintpl.github.io/docs/api-ru.html#unless), [with](http://snakeskintpl.github.io/docs/api-ru.html#with) и т.д.).

SS исправляет ряд неудачных архитектурных решений JS, например, переменные SS имеют блочную область видимости (подобно let из ES2015), а директива with устраняет недостатки удалённой из JS одноимённой конструкции.

#### Механизм фильтров

Фильтры используются в большинстве шаблонных движков, но в SS они пронизывают весь язык, т.е. мы можем использовать их буквально везде: при создании переменных, в циклах, при декларации параметров функций.

```
- namespace myApp
- template main((str|trim), name = ('World'|lower))
  - var a = {foo: 'bar'} |json
```

[Подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#filters).

#### Двусторонняя интеграция с JS

JS код может вызывать шаблоны SS, а SS может импортировать модули JS с помощью директивы [import](#http://snakeskintpl.github.io/docs/api-ru.html#import), а также поддерживает все основные виды модулей: umd, amd, commonjs, native и global.

```
- namespace myApp
- import { readdirSync } from 'fs'

- template main((str|trim), name = ('World'|lower))
  - forEach readdirSync('./foo') => dirname
    {dirname}
```

#### Встроенный механизм локализации шаблонов

[Подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#localization).

#### Встроенный механизм интеграции с другими шаблонами (в том числе с JSX)

**Пример с React:**

```
- namespace myComponent
- template render()
  < .hello
    {{ this.name }}
```

```js
import React from 'react';
import { myComponent } from './myComponent.ss';

const Foo = React.createClass({
  render: myComponent.render
});
```

Для бесшовной интеграции используется WebPack плагин c флагом `jsx`.

[Подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#introLiteral).

#### Полный контроль за пробельными символами

[Подробнее](http://snakeskintpl.github.io/docs/guide-ru.html#introTemplates--%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0_%D1%81_%D0%BF%D1%80%D0%BE%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC%D0%B8_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%B0%D0%BC%D0%B8).

Также см. раздел ["Работа с пробельными символами"](http://snakeskintpl.github.io/docs/api-ru.html#ignoreWhitespaces).

#### Поддержка ссылок на родительский класс

Подобно Sass или Stylus, в SS есть способ ссылаться на родительский класс - это удобно при использовании БЭМ подхода.

```
- namespace myApp
- template main()
  < .hello
    /// hello__wrap
    < .&__wrap
      /// hello__cont
      < .&__cont 
```

Принцип работы следующий: если при декларации тега задать имя класса, которое начинается с символа `&`, 
то он будет заменён на ближайший родительский класс, который декларировался без этого символа.

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#tag--%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D0%BD%D0%B0_%D1%80%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D0%BB%D0%B0%D1%81%D1%81).

#### Умная интерполяция

Многие директивы Snakeskin поддерживают механизм интерполяции, т.е. прокидывание динамических значений шаблона в директивы, например:

```
- namespace myApp
- template main(area)
  < ${area ? 'textarea' : 'input'}.b-${area ? 'textarea' : 'input'}
    Бла бла бла
```

В данном примере SS поймёт, какой код нужно генерировать в зависимости от значений и для `area == true` это будет

```html
<textarea class="b-textarea">
  Бла бла бла
</textarea>
```

А для `area == false`

```html
<input class="b-input" value="Бла бла бла">
```

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#tag--%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F).

#### Лёгкая интеграция различных плагинов

Благодаря механизму декораторов Snakeskin позволяет легко интегрировать дополнительные модули, например, типограф, проверку орфографии.

```
- namespace demo
- import Typograf from 'typograf'

- template typograf(params)
  - return
    () => target
      - return
        () =>
          - return new Typograf(params).execute(target.apply(this, arguments))

- @typograf({lang: 'ru'})
- template index()
  Спорт - это правильно!
```

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#template--%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B).

#### Асинхронные шаблоны

SS позволяет создавать шаблоны-генераторы и async-шаблоны, а также содержит ряд директив для удобного использования
популярной библиотеки Async.

```
- namespace myApp

- async template main(db)
  - forEach await db.getData() => el
    {el}

- template *foo(data)
  - for var i = 0; i < data.length; i++
    {data.value}
    
    - if i % 1e3 === 0
      - yield
```

[Подробнее](http://snakeskintpl.github.io/docs/api-ru.html#template--%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0).

Также см. раздел ["Директивы для асинхронной работы"](http://snakeskintpl.github.io/docs/api-ru.html#series).

#### Поддержка генерации как строк, так и DocumentFragment

Шаблоны Snakeskin по умолчанию возвращают строки, но также могут генерировать и DocumentFragment, а также есть возможность перегрузить эту операцию, например, чтобы сгенерировать свой vDOM.

#### Отладчик кода

В Snakeskin встроен мощный отладчик кода, который помогает находить большинство синтаксических и логических ошибок при трансляции шаблонов.

#### Интеграция со всеми основными системами сборок

[Gulp](https://github.com/SnakeskinTpl/gulp-snakeskin), [Grunt](https://github.com/SnakeskinTpl/grunt-snakeskin), [WebPack](https://github.com/SnakeskinTpl/snakeskin-loader).

#### Хорошая кодовая база

Snakeskin полностью написан на ES2015, содержит большое количество тестов и проходит максимально строгую проверку Google Closure Compiler в режиме ADVANCED. Код хорошо документирован в соответствии со стандартом JSDoc от Google.

#### Большая и подробная [документация](http://snakeskintpl.github.io/docs/index-ru.html).

Которая, кстати, [написана на Snakeskin](https://github.com/SnakeskinTpl/docs/tree/gh-pages/tpls).

## Заключение

Я очень бегло рассмотрел функционал языка, но думаю, что те кто заинтересовался проследуют в [документацию](http://snakeskintpl.github.io/docs/api-ru.html) и продолжат изучение.

Если кто желает помочь с переводом доки на английский, то прошу присылать PR на файлы в папке [en](https://github.com/SnakeskinTpl/docs/tree/gh-pages/docs/en).

О найденных багах пишите в [Issues](https://github.com/SnakeskinTpl/Snakeskin/issues) на GitHub-e проекта.
Задавать вопросы можно там же.

Всем спасибо за внимание и хорошего дня!
